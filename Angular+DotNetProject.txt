1) To Create Projevt 

   a) Command -- npm install -g @angular/cli  --- he tumchya machine vr angular che version insatll karel globally 

Atta project create karnya sathi -- ng new frontend 

b) Ata project run karnya sathi 

ng serve --open --- kele ki localhost 4200 vr project run hoil 

c) Atat jr kontya dusrya port vr jr aplya project run karaycha asel tr 

ng serve --port 4300   -- Hi COmmand use karaychi 

d) To Install Boot strap --- npm install bootstrap@5.3.8 --save __ Hivali command run karne

e) So landing page la app.html madhle je khi data asel tya ve aple page land hote starting vale page 

----------------------------------
d) Component Routing 
  ng g c <component_Name>  --- hi command component banvto --  Component mhnje apn pages banvnar like hearder cha page -- Angular 19 ha ata stand alone component abnvto 
  
  ng g s <Service Name>   --- hi service banvto
  
  bg g guard <guardname>   --- hi authentication banvto 
  
  ng g i <interface name> --- to create interface 
  
  ng g interceptor <interceptor_name>  to create interceptor
  
  -------------------------------------------------------------------------------------
  
  1) routing sathi 
  
  app.route.ts file madhe saglya page url routing tharvli jate 
  
  For Example---
  
  export const routes: Routes = [
    { path: '', redirectTo: 'home', pathMatch: 'full' },
    { path: 'home', component: Home },
    { path: '**', redirectTo: 'home' },
    { path: 'inventory', component: Inventory },
    { path: 'customer', component: Customer },
    { path: 'bill', component: Bill }
];

-----------------------------------------------------



ase kelya vr to jato router kade ani tya madhe jo route asel to bghto otherwise default route konta he to bghto ani tyacha component anto 

----------------------------------------------------------------------------

Now We are going to create Web API 

-----------------------------------------------------------------------------
1) How we can create a connection with Database 


      SqlConnection connection = new SqlConnection
      {
        ConnectionString = "Server=(localdb)\\MSSQLLocalDB;Database=techDb;"
      };

      SqlCommand command = new SqlCommand
      {
        CommandText = "" , --- Ithe producre name yete 
        CommandType = System.Data.CommandType.StoredProcedure , -----  He tumhlala sangte kontya type chi command ahe te (insert update dleete procude ase ) 
		 Connection = connection  -- ith query fire karnya stahi connection provide kakrayche aste 
      };


 Tatr ata aplya excute krnya stahi connection 1) open 2) execute and 3) close 
 Ya 3 gosti karavya lagtat so tya sathi 
 
   command.Parameters.AddWithValue("@ProductId", inventoryDto.ProductId);-------------------- @ProductId ha database chya producre cha varibale ki jyala method cchya para madhe yenarya DTO chya ProductId Barobr match kela jatoy

  connection.Open();    -- connection open krte 
 command.ExecuteNonQuery(); --- vr command madhe je ky logic ahe query che te execute karel 

 connection.Close(); --- Kaam jhalya vr connection close karel.
 
 return Ok("Inventory data saved successfully.");
 

 --------------------------------------------------------
 
1) Query Execution in Dot net 

create table Inventory(
  Id int Identity(1,1) primary key,
  ProductId int ,
  ProductName varchar(100),
  StockAvailable int,
  ReorderStock int
)

Here The 
This SQL code snippet is a Data Definition Language (DDL) statement used to 
create a structured table named Inventory within a database. It defines how data regarding product stock levels will be stored and managed.

Identity(1,1)  ---- The unique identifier for each row. It starts at 1 and increases by 1 for every new record automatically.Identity(1,1): This is specific to SQL Server (T-SQL). It means the database handles the ID generation for you. 
You don‚Äôt need to provide a value for Id when inserting new data; the system will handle it ($1, 2, 3...$).


primary key    ---- Ensures this column is unique and not null, making it the main reference point for each row.This is the most important constraint. 
It prevents duplicate rows and allows the database to retrieve data much faster via indexing.




---------------------------------------------------------------------------------

How to create an procudure 

open database ------  then click on programitibility ----- Then Right click on procudures and click on create stored procudre -- you SP get creted


---------------------------------------------------------------------------------

How to refresh chace in datavase 

press Ctrl + Shift + R.

This refreshes the IntelliSense cache. The red lines should disappear, allowing you to run your code without visual errors.
________________________________________________________________________________________________

#region 

is used for code readability

Helps collapse/expand code sections in Visual Studio

‚ö†Ô∏è It has no effect at runtime
It‚Äôs only for developer convenience

_____________________________________________________________________________________________________
      command.Parameters.AddWithValue("@ProductId", inventoryDto.ProductId);
	  
	  @ProductId ha database chya producre cha varibale ki jyala method cchya para madhe yenarya DTO chya ProductId Barobr match kela jatoy
	  
_____________________________________________________________________________________________________
	  
	  Now How we can connect with frontent ot back end 
	  
	 1) 1st just Open you invertory.ts file and write below code for routing 
	 
	 
	 
	 CODE---->>
	 
	 export class Inventory {

  httpClient = inject(HttpClient);

  inventoryData = {
    productId: '',
    productName: '',
    stockAvailable: 0,
    reorderStock: 0
  };

  onSubmit() {
    let apiUrl = 'https://localhost:7273/api/inventory';
    let httpOptions = {
      headers: new HttpHeaders({
        Authorization: 'Mahesh-auth-token',
        'Content-Type': 'application/json'
      })
    };
    this.httpClient.post(apiUrl, this.inventoryData, httpOptions).subscribe(

      {
        next: v => console.log('Inventory data submitted successfully', v),
        error: e => console.error('Error submitting inventory data', e),
        complete: () => {
          alert('Inventory data submission process completed.' + JSON.stringify(this.inventoryData));
        }
      }
    );
  }
}

Now under stand the code ;ine by line 

1) 1export class Inventory {

							Defines a TypeScript class named Inventory
							export ‚Üí allows this class to be used in other files
							This class is typically used as:
							an Angular component
							or service logic handling inventory data
							
2) httpClient = inject(HttpClient);

							üîç What is happening?
							Angular Dependency Injection
							HttpClient is Angular‚Äôs built-in service for making HTTP calls (GET, POST, PUT, DELETE)
							üí° Why inject()?
							This is Angular 14+ syntax
							Alternative to constructor injection

3) inventoryData = { ... } 
   inventoryData = {
  productId: '',
  productName: '',
  stockAvailable: 0,
  reorderStock: 0
};							üîç Purpose
							Holds form data
							Bound to input fields using ngModel or reactive forms
							This object will be sent to the backend API							
							
4) onSubmit() {

				This function is triggered when:
				a form is submitted
				or a Submit button is clicked							
	
	HTML Will be look like -- <button (click)="onSubmit()">Submit</button>

5) let apiUrl = 'https://localhost:7273/api/inventory';
															üîç What is this?
															Backend ASP.NET Core Web API endpoint
															Your Angular app sends data to this URL
												
		Mhnje Backend la ase mapp kele jail-- 
		                                   [HttpPost]
                                           [Route("api/inventory")]
                                           public IActionResult AddInventory(Inventory model) { }

6) let httpOptions = { headers: new HttpHeaders({ ... }) }
											üîç Purpose
											Adds HTTP headers to the request	
											
headers: new HttpHeaders({
  Authorization: 'Mahesh-auth-token',
  'Content-Type': 'application/json'
})
üìå Explanation of headers:
Header	Purpose
1) Authorization	Used for authentication (JWT / token)
2) Content-Type	Tells server that request body is JSON	


7) this.httpClient.post(...)

 this.httpClient.post(apiUrl, this.inventoryData, httpOptions)

üîç What happens?

Sends an HTTP POST request
Data sent:
URL ‚Üí apiUrl
Body ‚Üí inventoryData
Headers ‚Üí httpOptions

Raw Http -- 

POST /api/inventory
Content-Type: application/json

{
  "productId": "...",
  "productName": "...",
  "stockAvailable": 10,
  "reorderStock": 5
}


8) .subscribe({ ... })

üîç Why subscribe()?
HTTP calls are asynchronous
subscribe() listens for the response

9) next: v => console.log(...)

next: v => console.log('Inventory data submitted successfully', v)

Called when API returns success (200/201)
v contains:
response from backend
Logs success message to console.

10)error: e => console.error(...) 
error: e => console.error('Error submitting inventory data', e)
Called when:
API fails (400, 401, 500)
Network error
Logs error details to console

11) complete: () => { ... }
complete: () => {
  alert('Inventory data submission process completed.' + JSON.stringify(this.inventoryData));
}

üîç When is this called?
After next OR error
Signals request lifecycle completion
‚ö†Ô∏è Important Note:
complete() does NOT mean success, it only means:
request finished
Better practice:
Show success alert in next

üîÅ Flow Summary

1) User fills form
2) Clicks Submit
3) onSubmit() is triggered
4) POST request sent to backend
5) Backend processes data
6) Angular handles:
    A) next ‚Üí success
    B) error ‚Üí failure
    C) complete ‚Üí request finished